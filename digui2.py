#回文联


def is_palindrome(n, start, end):  # 定义一个函数，三个形参。n为整个字符串内容，start为开始索引位置，end为末尾索引位置。
    if start > end:  # 如果 start的索引大于末尾索引位置的时，返回真值，表示已经判定过整个字符串了，一开始我也一脸懵逼，后来仔细想想明白了：
        # 假定字符串有五个长度[0,5]，（最好在纸上写下0 1 2 3 4 五个数字）
        # 当开始索引[2]=末尾索引[2]的时候，双方都指在中间数2这个位置的时候，就已经检查完毕，那为什么要判定大于的情况呢？

        # 假定字符串有四个长度[0,4]呢？(0 1 2 3),怎么才能索引个遍呢？
        # 很明显，只有当开始索引[2]>末尾索引[1]的时候，开始指在2，末尾指在1的时候，才算索引个遍，这个大于判定就这么来的。

        return 1  # 返回一个真值，（不为零即可，返回几百几千随便。）
    else:
        return is_palindrome(n, start + 1, end - 1) if n[start] == n[
            end] else 0  # 这个语句判断的就是未完成检查的情况，从字符串0根末尾索引-1比较（不知道为何减一的同学面壁）。
        # 依次开始第二位跟倒数第二位，开始第三位跟倒数第三位……

        # 不相同的话就返回0，非真，假值。


string = input('请输入一串字符串：')
length = len(string) - 1  # 不知道为何减1的同学面壁。

if is_palindrome(string, 0, length):  # 这里传入三个实参，如果if为真值，也就是不为零，非真，假值的情况下（不为零的情况下就包含上面函数的判定：1、从头到位的检索，2、字符串的比较是否相等）
    print('"%s"是回文字符串!' % string)  # 是真的情况下打印是回文联
else:
    print('"%s"不是回文字符串!' % string)  # 否则打印不是回文联。


